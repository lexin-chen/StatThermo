# -*- coding: utf-8 -*-
"""metropolis-monte-carlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1II8j-CZmprKKJ-RflfnmYEstZfr7OZ8_

# Question 1
"""

#1a
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0,10,100)
y=(x - 5)**2

plt.plot(x,y,color='red',label='100K')

#1c
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
#define variables
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
list = np.arange(0,10,.1)
#p1.clear()
#p2.clear()
#p3.clear()
f= lambda x:exp((-k * (x - 5) ** 2) / kB / t1) 
j = scipy.integrate.quad(f, 0, 10)
p1=[]
for i in list:
  num=math.pow(math.e,(-k*(i-5)**2)/(kB * t1)) #p(x)=e^(-v(x)/kBT)
  p1.append(num/j[0])

p2=[]
f= lambda x:exp((-k * (x - 5) ** 2) / kB / t2) 
j = scipy.integrate.quad(f, 0, 10)

for i in list:
  num1 = math.pow(math.e,(-k*(i - 5)**2)/(kB*t2)) #p(x)=e^(-v(x)/kBT)/integral of same thing
  p2.append(num1/j[0])

p3=[]
def f(x):
 return exp((-k * (x - 5) ** 2) / kB / t3) 
j = scipy.integrate.quad(f, 0, 10)
for i in list:
  num2=math.pow(math.e,(-k*(i-5)**2)/(kB*t3)) #p(x)=e^(-v(x)/kBT)
  p3.append(num2/j[0])

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")
plt.plot(list,p1,color='red',label='100K')
plt.plot(list,p2,color='gold',label='300K')
plt.plot(list,p3,color='blue',label='1000K')
plt.legend()

#1f <x>
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
average = []

for n in [t1, t2, t3]:
  def f(x):
    return exp((-k * (x - 5) ** 2) / kB / n)
  g = lambda x: x * exp((-k * (x - 5) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show

#1f , <x**2>
average1=[]
#average1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp((-k * (x - 5) ** 2) / kB / n)
  g = lambda x: x**2 * exp((-k**2 * (x - 5) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average1, '-or', label='Averages')
plt.show

#1f , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp((-k * (x - 5) ** 2) / kB / n)
  g = lambda x: (x - 5) ** 2 * exp((-k**2 * (x - 5) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show

"""# New Section

# Question2

1d.temperature does not play a role therefore, it does not change

https://chryswoods.com/intro_to_mc/part1/metropolis.html
"""

#2b -100K
import random
import math
import matplotlib.pyplot as plt
from timeit import default_timer as timer
kB = 8.314e-3 # R
T = 100
k = 1
start = timer()
def V1(x):
  return (x - 5) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list =[] # creating a list for all the steps partook
eng_list = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(100000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list.append(new_energy) 
    steps_list.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list.append(old_energy)
    steps_list.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list = steps_list[1000:] #get rid of first 10% of steps
eng_list = eng_list[1000:] #get rid of first 10% of energies
print(len(eng_list)) #proofs that first 10% of the numbers were discarded
#print(steps_list)
#print(eng_list)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list,eng_list,label='100K')

plt.legend()
end = timer()
print(f'sequentially: {end - start}')

#2b - 100K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

#prob_density = kde.gaussian_kde(steps_list)
#prob_density.covariance_factor = lambda : .25
#prob_density._compute_covariance()

x = np.linspace(0,10,100000)
#y=prob_density(x)
print(len(steps_list))

#plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list, bins=50, density = True)
plt.show()

#2b -300K
import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
T = 300
k = 1
def V1(x):
  return (x - 5) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list1 =[] # creating a list for all the steps partook
eng_list1 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(100000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list1.append(new_energy) 
    steps_list1.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list1.append(old_energy)
    steps_list1.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list1 = steps_list1[1000:] #get rid of first 10% of steps
eng_list1 = eng_list1[1000:] #get rid of first 10% of energies
print(len(eng_list1)) #proofs that first 10% of the numbers were discarded
#print(steps_list1)
#print(eng_list1)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list1,eng_list1,label='300K')

plt.legend()

#2b - 300K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list1)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(0,10,100000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list1, bins=100, density = True)
plt.show()

eng_list.clear()
steps_list2.clear()
#2b -1000K
import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
T = 1000
k = 1
def V1(x):
  return (x - 5) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list2 =[] # creating a list for all the steps partook
eng_list2 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(100000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list2.append(new_energy) 
    steps_list2.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list2.append(old_energy)
    steps_list2.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list2 = steps_list2[1000:] #get rid of first 10% of steps
eng_list2 = eng_list2[1000:] #get rid of first 10% of energies
print(len(eng_list2)) #proofs that first 10% of the numbers were discarded
#print(steps_list2)
#print(eng_list2)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list2,eng_list2,label='100K')

plt.legend()

#2b - 1000K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list2)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(0,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list2, bins=100, density = True)
plt.show()

#2d <x> #run 2b montecarlo again if this doesn't work
average = []


def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           
    
    avg = sum_num / len(num)
    return avg
for i in [steps_list,steps_list1,steps_list2]:
  average.append(cal_average(i))
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show

average1 = []
def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           

    avg = sum_num / len(num)
    return avg ** 2
for i in [steps_list,steps_list1,steps_list2]:
  average1.append(cal_average(i))
plt.plot([t1, t2, t3], average1, '-or', label='Averages')
plt.show

#2d , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp((-k * (x - 5) ** 2) / kB / n)
  g = lambda x: (x - 5) ** 2 * exp((-k**2 * (x - 5) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show

"""# Question3"""

#3a
import matplotlib.pyplot as plt
De = 10
a = 0.31
x0 = 5
x = np.linspace(0,10,100)
y= De * (1 - exp( -a * (x - x0))) ** 2
plt.title("V(2) vs x.")
plt.plot(x,y,color='red')

import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
#define variables
#plt.close()
De = 10
a = 0.31
x0 = 5
t1=100 
t2=300
t3=1000
kB=8.314e-3
list = np.arange(0,10,.1)
p1.clear()
p2.clear()
p3.clear()
f= lambda x:exp(-De * (1 - exp( -a * (x - x0))) ** 2 / kB / t1) 
j = scipy.integrate.quad(f, 0, 10)
#f= lambda x:exp((10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / t1) 
#j = scipy.integrate.quad(f, 0, 5)
print(j)
p8=[]
for i in list:
  #num=math.pow(math.e,(10 * (1 - exp( -0.31 * (i - 5))) ** 2)/(kB * t1)) #p(x)=e^(-v(x)/kBT)
  num = exp(-De * (1 - exp( -a * (i - x0))) ** 2 / kB / t1) 
  #p1.append(num)
  p8.append(num/j[0])#
print(p8)
p2=[]
f= lambda x:exp((-10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / t2) 
j = scipy.integrate.quad(f, 0, 10)

for i in list:
  num1 = math.pow(math.e,(-10 * (1 - exp( -0.31 * (i - 5))) ** 2)/(kB*t2)) #p(x)=e^(-v(x)/kBT)/integral of same thing
  #p2.append(num1)
  p2.append(num1/j[0])

p3=[]
def f(x):
 return exp((-10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / t3) 
j = scipy.integrate.quad(f, 0, 10)
for i in list:
  num2=math.pow(math.e,(-10 * (1 - exp( -0.31 * (i - 5))) ** 2)/(kB*t3)) #p(x)=e^(-v(x)/kBT)
  #p3.append(num2)
  p3.append(num2/j[0])

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")
plt.plot(list,p8,color='red',label='100K')
plt.plot(list,p2,color='gold',label='300K')
plt.plot(list,p3,color='blue',label='1000K')
plt.legend()

#3d <x>
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
average = []

for n in [t1, t2, t3]:
  def f(x):
    return exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  g = lambda x: x * exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show

#3d , <x**2>
average1=[]
#average1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  g = lambda x: x**2 * exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average1, '-or', label='Averages')
plt.show

#3d , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  g = lambda x: 10 * (1 - exp( -0.31 * (x - 5))) ** 2 * exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show

"""# Question4"""

#4b - 100 K

import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
De = 10
a = 0.31
x0 = 5
T = 100

def V1(x):
  return De * (1 - math.pow(math.e, -a * (x - x0))) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list3 =[] # creating a list for all the steps partook
eng_list3 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(10000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list3.append(new_energy) 
    steps_list3.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list3.append(old_energy)
    steps_list3.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list3 = steps_list3[1000:] #get rid of first 10% of steps
eng_list3 = eng_list3[1000:] #get rid of first 10% of energies
print(len(eng_list3)) #proofs that first 10% of the numbers were discarded
print(steps_list3)
print(eng_list3)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list3,eng_list3,label='100K')

plt.legend()

#4b - 100K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list3)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(0,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list3, bins=100, density = True)
plt.show()

#4b - 300 K

import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
De = 10
a = 0.31
x0 = 5
T = 300

def V1(x):
  return De * (1 - math.pow(math.e, -a * (x - x0))) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list4 =[] # creating a list for all the steps partook
eng_list4 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(10000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list4.append(new_energy) 
    steps_list4.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list4.append(old_energy)
    steps_list4.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list4 = steps_list4[1000:] #get rid of first 10% of steps
eng_list4 = eng_list4[1000:] #get rid of first 10% of energies
print(len(eng_list4)) #proofs that first 10% of the numbers were discarded
print(steps_list4)
print(eng_list4)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list4,eng_list4,label='300K')

plt.legend()

#4b - 300K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list4)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(0,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list4, bins=100,density = True)
plt.show()

#4b - 1000 K

import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
De = 10
a = 0.31
x0 = 5
T = 1000

def V1(x):
  return De * (1 - math.pow(math.e, -a * (x - x0))) ** 2 # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list5 =[] # creating a list for all the steps partook
eng_list5 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < 0 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(10000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list5.append(new_energy) 
    steps_list5.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list5.append(old_energy)
    steps_list5.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < 0 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list4 = steps_list5[1000:] #get rid of first 10% of steps
eng_list4 = eng_list5[1000:] #get rid of first 10% of energies
print(len(eng_list5)) #proofs that first 10% of the numbers were discarded
print(steps_list5)
print(eng_list5)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list5,eng_list5,label='100K')

plt.legend()

#4b - 1000K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list5)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(0,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list5, bins=100, density = True)
plt.show()

#4d <x>
average = []
def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           

    avg = sum_num / len(num)
    return avg
for i in [steps_list3,steps_list4,steps_list5]:
  average.append(cal_average(i))
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show

#4d <x**2>
average1 = []
def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           

    avg = sum_num / len(num)
    return avg ** 2
for i in [steps_list3,steps_list4,steps_list5]:
  average1.append(cal_average(i))
plt.plot([t1, t2, t3], average1, '-or', label='Averages')
plt.show

#4d , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  g = lambda x: 10 * (1 - exp( -0.31 * (x - 5))) ** 2 * exp(-(10 * (1 - exp( -0.31 * (x - 5))) ** 2) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show

"""# Question5"""

#5a
import matplotlib.pyplot as plt
De = 10
a = 0.31
x0 = 5
x = np.linspace(-10,10,100)
def V3(x):
 return - 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)

plt.title("V(3) vs x.")
plt.plot(x,V3(x),color='red')

#5b
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
#define variables
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
list = np.arange(-10,10,.1)
#p1.clear()
#p2.clear()
#p3.clear()

x_range = np.arange(-3,0.01, 0.0001)
V3_range = np.array([V3(x) for x in x_range])
x_barrier = x_range[np.argmax(V3_range)]
print('x(barrier)=' +str(x_barrier))

f= lambda x:exp(-(- 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) / kB / t1) 
j = scipy.integrate.quad(f, -10, 10)
a = scipy.integrate.quad(f, -10, 6.330935775622493e-12)
print('At 100K, P(left)=' + str(a[0]/j[0]))
print('At 100K, P(right)=' + str(1-(a[0]/j[0])))
p1=[]
for i in list:
  num=math.pow(math.e,-(- 10 * exp(-(i + 3)**2) - 10 * exp(-(i - 3)**2))/(kB * t1)) #p(x)=e^(-v(x)/kBT)
  p1.append(num/j[0])


p2=[]
f= lambda x:exp(-(- 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) / kB / t2) 
j = scipy.integrate.quad(f, -10, 10)
a = scipy.integrate.quad(f, -10, 6.330935775622493e-12)
print('At 300K, P(left)=' + str(a[0]/j[0]))
print('At 300K, P(right)=' + str(1-(a[0]/j[0])))
for i in list:
  num1 = math.pow(math.e,-(- 10 * exp(-(i + 3)**2) - 10 * exp(-(i - 3)**2))/(kB*t2)) #p(x)=e^(-v(x)/kBT)/integral of same thing
  p2.append(num1/j[0])

p3=[]
def f(x):
 return exp(-(- 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) / kB / t3) 
j = scipy.integrate.quad(f, -10, 10)
print(f(-6),j[0],f(-6)/j[0])
a = scipy.integrate.quad(f, -10, 6.330935775622493e-12)
print('At 1000K, P(left)=' + str(a[0]/j[0]))
print('At 1000K, P(right)=' + str(1-(a[0]/j[0])))
for i in list:
  num2=math.pow(math.e,-(- 10 * exp(-(i + 3)**2) - 10 * exp(-(i - 3)**2))/(kB*t3)) #p(x)=e^(-v(x)/kBT)
  p3.append(num2/j[0])

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")
plt.plot(list,p1,color='red',label='100K')
plt.plot(list,p2,color='gold',label='300K')
plt.plot(list,p3,color='blue',label='1000K')
plt.legend()

#5f <x>
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
average = []

for n in [t1, t2, t3]:
  def f(x):
    return exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  g = lambda x: x * exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  k1 = scipy.integrate.quad(f, -10, 10)
  k2 = scipy.integrate.quad(g, -10, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show()

#5f <x>
import scipy.integrate
from numpy import exp
import matplotlib.pyplot as plt
import numpy as np
import random
import math 
t1=100 
t2=300
t3=1000
k=1
kB=8.314e-3
average = []

for n in [t1, t2, t3]:
  def f(x):
    return exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  g = lambda x: x ** 2 * exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  k1 = scipy.integrate.quad(f, -10, 10)
  k2 = scipy.integrate.quad(g, -10, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  average.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show()

#5f , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  g = lambda x: (-10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) * exp((+ 10 * exp(-(x + 3)**2) + 10 * exp(-(x - 3)**2)) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show

"""# Question6"""

#6b -100K
import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
T = 100
k = 1
def V1(x):
  return - 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2) # defining equation for boltzmann distribution

old_num = random.uniform(-10,10) # picking a random number between 0 to 10
steps_list6 =[] # creating a list for all the steps partook
eng_list6 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < -10 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(100000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list6.append(new_energy) 
    steps_list6.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list6.append(old_energy)
    steps_list6.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < -10 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list6 = steps_list6[1000:] #get rid of first 10% of steps
eng_list6 = eng_list6[1000:] #get rid of first 10% of energies
print(len(eng_list6)) #proofs that first 10% of the numbers were discarded
#print(steps_list6)
#print(eng_list6)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list6,eng_list6,label='100K')

plt.legend()

#6b - 100K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde


prob_density = kde.gaussian_kde(steps_list6)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(-10,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list6, bins=100, density = True)
plt.show()

#5e
x_range = np.arange(-3,0.01, 0.0001)
V3_range = np.array([V3(x) for x in x_range])
x_barrier = x_range[np.argmax(V3_range)]
print('x(barrier)=' +str(x_barrier))

f= lambda x:prob_density(x)
j = scipy.integrate.quad(f, -10, x_barrier)
print('At 100K, P(left)=' + str(j[0]))
print('At 100K, P(right)=' + str(1-(j[0])))

#6b -300K
import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
T = 300
k = 1
def V1(x):
  return - 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2) # defining equation for boltzmann distribution

old_num = random.uniform(-10,10) # picking a random number between 0 to 10
steps_list7 =[] # creating a list for all the steps partook
eng_list7 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < -10 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(10000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list7.append(new_energy) 
    steps_list7.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list7.append(old_energy)
    steps_list7.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < -10 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list7 = steps_list7[1000:] #get rid of first 10% of steps
eng_list7 = eng_list7[1000:] #get rid of first 10% of energies
print(len(eng_list7)) #proofs that first 10% of the numbers were discarded
print(steps_list7)
print(eng_list7)
print('{} + {}'.format(naccept, nreject))

plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list7,eng_list7,label='100K')

plt.legend()

#6b - 300K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list7)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(-10,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list7, bins=100, density = True)
plt.show()

#6e - 300K
x_range = np.arange(-3,0.01, 0.0001)
V3_range = np.array([V3(x) for x in x_range])
x_barrier = x_range[np.argmax(V3_range)]
print('x(barrier)=' +str(x_barrier))

f= lambda x:prob_density(x)
j = scipy.integrate.quad(f, -10, x_barrier)
print('At 300K, P(left)=' + str(j[0]))
print('At 300K, P(right)=' + str(1-(j[0])))

#6b -1000K
import random
import math
import matplotlib.pyplot as plt
kB = 8.314e-3 # R
T = 1000
k = 1
def V1(x):
  return - 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2) # defining equation for boltzmann distribution

old_num = random.uniform(0,10) # picking a random number between 0 to 10
steps_list8 =[] # creating a list for all the steps partook
eng_list8 = [] # list of corresponding energies

D = 5 # defining the range that it shall move along the x-axis
delta_x = random.uniform(-D, D)
num = old_num + delta_x # moving the old_num along some value

while num < -10 or num > 10:
  delta_x = random.uniform(-D, D)
  num = old_num + delta_x

accept = False
nreject=0
naccept=0
# Automatically accept if the energy goes down
for i in range(10000): # defining the # of bins

  new_energy=V1(num) # calculate the new energy
  old_energy=V1(old_num)
  
  dE = new_energy - old_energy 
  if (dE <= 0): 
    accept = True # accept the move if the difference between old and energy energy is less than 0
    
  else:
    # Now apply the Monte Carlo test - compare
    # exp( -(E_new - E_old) / kT ) >= rand(0,1)
    x = math.exp( -(dE) / (kB*T) )
    #print(x)
    if (x >= random.uniform(0.0,1.0)):
      accept = True
      
    else:
      accept = False
      
  if accept == True:
    naccept += 1 # if move accepted +1
    eng_list8.append(new_energy) 
    steps_list8.append(num)
    old_num = num # replace the num as old_num so it can go into the loop again with an updated number
    old_energy = new_energy
  else:
    nreject += 1 # reject the move - restore the old number
    eng_list8.append(old_energy)
    steps_list8.append(old_num)

  delta_x = random.uniform(-D, D) # move again
  num = old_num + delta_x
  while num < -10 or num > 10:
    delta_x = random.uniform(-D, D)
    num = old_num + delta_x

T = 100
V1 = lambda x: math.pow(math.e, (-k * (x - 5) ** 2) / kB / T)

steps_list8 = steps_list8[1000:] #get rid of first 10% of steps
eng_list8 = eng_list8[1000:] #get rid of first 10% of energies
print(len(eng_list8)) #proofs that first 10% of the numbers were discarded
print(steps_list8)
print(eng_list8)
print('{} + {}'.format(naccept, nreject))

#plt.title("P(x) vs x.")
plt.xlabel("x")
plt.ylabel("P(x)")

plt.scatter(steps_list8,eng_list8,label='100K')

plt.legend()

#6b - 1000K
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kde

prob_density = kde.gaussian_kde(steps_list8)
prob_density.covariance_factor = lambda : .25
prob_density._compute_covariance()

x = np.linspace(-10,10,10000)
y=prob_density(x)

plt.plot(x, y)
plt.title("Density Plot of the data")
plt.hist(steps_list8, bins=100, density = True)
plt.show()

#6e - 1000K
x_range = np.arange(-3,0.01, 0.0001)
V3_range = np.array([V3(x) for x in x_range])
x_barrier = x_range[np.argmax(V3_range)]
print('x(barrier)=' +str(x_barrier))

f= lambda x:prob_density(x)
j = scipy.integrate.quad(f, -10, x_barrier)
print('At 1000K, P(left)=' + str(j[0]))
print('At 1000K, P(right)=' + str(1-(j[0])))

average = []
def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           

    avg = sum_num / len(num)
    return avg
for i in [steps_list6,steps_list7,steps_list8]:
  average.append(cal_average(i))
plt.plot([t1, t2, t3], average, '-or', label='Averages')
plt.show

average1 = []
def cal_average(num):
    sum_num = 0
    for t in num:
        sum_num = sum_num + t           

    avg = sum_num / len(num)
    return avg ** 2
for i in [steps_list6,steps_list7,steps_list8]:
  average1.append(cal_average(i))
plt.plot([t1, t2, t3], average1, '-or', label='Averages')
plt.show

#3d , <V1>
V1=[]
#V1.clear()
for n in [t1, t2, t3]:
  def f(x):
    return exp(-(- 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) / kB / n) 
  g = lambda x: - 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2) ** 2 * exp(-(- 10 * exp(-(x + 3)**2) - 10 * exp(-(x - 3)**2)) / kB / n)
  k1 = scipy.integrate.quad(f, 0, 10)
  k2 = scipy.integrate.quad(g, 0, 10)
  print('{} / {}'.format(k2[0], k1[0]))

  V1.append(k2[0] / k1[0])
plt.plot([t1, t2, t3], V1, '-or', label='Averages')
plt.show